## 문제

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

---

## 입력

첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

---

## 출력

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

---

## 풀이

```python
n, k = list(map(int, input().split()))
items = [tuple(map(int, input().split())) for i in range(n)]
dp = [[0 for _ in range(k + 1)] for _ in range(n)]

for i in range(n):
    for j in range(1, k + 1):
        if j >= items[i][0]:
            dp[i][j] = max(dp[i - 1][j - items[i][0]] + items[i][1], dp[i - 1][j])
        else:
            dp[i][j] = dp[i - 1][j]

print(dp[-1][-1])
```

준서가 버틸 수 있는 무게 한도 내에서 가치가 최대가 되도록 물건을 골랐을 때 가치의 합을 구하는 문제입니다. 유명한 0/1 배낭(Knapsack) 문제로 동적계획법(DP)를 사용하여 풀 수 있는 문제입니다.

| 인덱스 | 1    | 2    | 3    | 4    |
| ------ | ---- | ---- | ---- | ---- |
| 무게   | 6    | 4    | 3    | 5    |
| 가치   | 13   | 8    | 6    | 12   |

위와 같이 4개의 물품이 주어졌다고 했을 때 준서가 버틸 수 있는 무게가 8이라고 하면 메모이제이션을 위한 캐시를 다음과 같이 이차원 배열로 설정합니다.

| 물건 \| 무게 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 (6, 13)    | 0    | 0    | 0    | 0    | 0    | 0    | 13   | 13   |
| 2 (4, 8)     | 0    | 0    | 0    | 0    | 8    | 8    | 13   | 13   |
| 3 (3, 6)     | 0    | 0    | 0    | 6    | 8    | 8    | 13   | 14   |
| 4 (5, 12)    | 0    | 0    | 0    | 6    | 8    | 12   | 13   | 14   |

위의 표의 행은 해당 인덱스까지의 물품을 선택하는 방법으로, 예를 들어 2행은 (무게 6, 가치 13)의 물건과 (무게 4, 가치 8)의 물건을 고르는 경우를 나타냅니다. 열의 경우 최대 무게를 나타낸 경우로 2행 5열의 경우 (무게 6, 가치13), (무게 4, 가치 8)을 고르면서 최대 무게가 4가 되도록 했을 때 최대 가치를 나타냅니다. 1행부터 차례로 열들을 순회하면서 최대 가치를 저장해갑니다. 1행에서 무게 6 미만의 경우는 아무것도 고를 수 없으므로 0이 되고 무게가 6일 때 (무게 6, 가치 13)의 물건을 고르면서 최대 가치가 13이 됩니다.

이처럼 하나씩 채워가다보면 다음과 같은 규칙을 발견할 수 있습니다.

현재 물품의 무게를 w, 가치를 v라고 하고, 행 인덱스를 i 열 인덱스를 j라하면 아래와 같은 수식으로 나타낼 수 있습니다.
$$
dp[i][j] = max(dp[i-1][j-w]+v, dp[i-1][j])
$$
가령 2행 7열의 경우(물건을 2개 고르면서 무게가 최대 7인 경우), 물건을 1개 고르면서 최대 무게가 2인 경우에 현재 무게가 4인 물건을 추가로 고를 수 있습니다. 이 경우와 현재 물건을 고르지 않고 그대로 물건을 1개 고르면서 최대 무게가 그대로 6인 경우 중 최대인 값을 택하여 저장하면 현재 버틸 수 있는 무게 w에서 최대인 가치를 구할 수 있습니다. 이 때 주의할 점은 현재 물건의 무게보다 최대 무게가 낮은 경우 현재 물건은 선택할 수 없기 때문에 예외처리를 구현해야 합니다.

위 알고리즘을 파이썬으로 구현한 코드는 위와 같습니다.