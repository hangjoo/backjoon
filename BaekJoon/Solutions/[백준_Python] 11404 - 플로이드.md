## 문제

n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.

모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

---

## 입력

첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.

시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.

---

## 출력

n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

---

## 풀이

```python
from math import inf

n = int(input())
m = int(input())
connect = {i: {j: inf for j in range(1, n + 1)} for i in range(1, n + 1)}
for _ in range(m):
    src, dst, cost = map(int, input().split())
    if connect[src][dst] == inf:
        connect[src][dst] = cost
    elif connect[src][dst] > cost:
        connect[src][dst] = cost
dist = connect.copy()
for i in range(1, n + 1):
    dist[i][i] = 0

for k in range(1, n + 1):
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if dist[i][k] + connect[k][j] < dist[i][j]:
                dist[i][j] = dist[i][k] + connect[k][j]

for i in range(1, n + 1):
    for j in range(1, n + 1):
        if dist[i][j] == inf:
            print(0, end=" ")
        else:
            print(dist[i][j], end=" ")
    print()
```

주어진 그래프에서 모든 정점에 대해 다른 정점으로 가는 최소 비용을 출력하는 문제입니다.

문제 이름에서 보이듯 플로이드 와샬 알고리즘을 사용하는 문제입니다. 플로이드 와샬 알고리즘은 음의 가중치를 포함한(음의 사이클은 존재하지 않는) 그래프에서 모든 정점의 다른 정점에 대한 최단 경로를 찾는 알고리즘입니다. 간단하게 설명하면, 모든 출발 정점과 도착 정점에 대해 중간에 거쳐가는 정점과 곧바로 가는 경로를 비교하여 거쳐가는 경로가 더 짧으면 해당 경로로 갱신하는 과정을 통해 최단 경로를 구할 수 있습니다. 플로이드 와샬 알고리즘 자체는 어렵지 않기 때문에 코드를 통해 쉽게 이해하실 수 있습니다.

주의할 점은 두 정점간의 간선이 여러개 존재할 수 있으며 최단 경로를 구하기 위해서는 해당 간선들 중 짧은 간선만 택하면 되기 때문에 두 정점 사이의 최단 간선만 저장(Line 10 ~ 11)하도록 합니다.