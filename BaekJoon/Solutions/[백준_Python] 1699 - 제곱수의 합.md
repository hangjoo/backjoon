## 문제

어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=32+12+12(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=22+22+12+12+12(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.

주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)

## 출력

주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.

## 풀이

```python
n = int(input())

cases = [i for i in range(n + 1)]

for i in range(1, n + 1):
    for base_num in range(1, int(i ** 0.5) + 1):
        if cases[i - base_num * base_num] + 1 < cases[i]:
            cases[i] = cases[i - base_num * base_num] + 1

print(cases[-1])
```

주어진 자연수를 제곱수의 합으로 표현할 때 표현된 제곱수의 항의 개수가 최소가 될 때의 항의 개수를 구하는 문제입니다.

알고리즘 자체는 어려운 편이 아니였는데 제한 시간 초과 때문에 꽤나 시간을 쏟았던 문제입니다.

먼저 주어진 자연수 N은 자기 자신 N보다 작은 제곱수로 구성될 수 있기 때문에 자기 자신보다 작은 제곱수의 항의 최소 개수의 합으로도 표현할 수 있습니다. 즉, 문제에서 예시처럼 11은 9 + 1 + 1처럼 3개의 제곱수의 최소 개수 합으로 표현할 수 있습니다. 그러나 어떤 제곱수의 최소 개수 합으로 표현되는지는 알 수 없기 때문에 해당 과정은 위 코드처럼 순회해가면서 최소가 되는 제곱수 구성을 찾아가야 합니다.

이 때 이전에 구한 제곱수의 최소 개수는 다시 구할 필요가 없도록 cases 변수에 저장해가면서 계산하게 됩니다.

이렇게 알고리즘을 구성해서 코드를 구현하면 정답을 출력하는데는 문제가 없으나 코드를 어떻게 구현하냐에 따라 시간 제한에 아슬아슬하게 통과가 될 수도, 초과가 될 수도 있습니다. 저는 7, 8번 라인의 base_num을 제곱하는 코드를 ** 2에서 위와 같이 바꿔서 시간 제한을 통과했습니다.
