## 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

---

## 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

---

## 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

---

## 풀이

```python
n = int(input())
seq = list(map(int, input().split()))
dp = [1 for _ in range(n)]

for i in range(1, n):
    for j in range(i - 1, -1, -1):
        if seq[i] > seq[j] and dp[i] <= dp[j]:
            dp[i] = dp[j] + 1

print(max(dp))

```

문제 그래도 주어진 수열에서 증가하는 가장 긴 부분 수열을 찾는 문제입니다. 문제의 예처럼 주어진 수열이 {10, 20, 10, 30, 20 50} 일 때 가장 긴 증가하는 부분 수열은 인덱스 0, 1, 3, 5 수열인 {10, 20, 30, 50}으로 길이가 4 입니다.

주어진 수열의 최대 길이는 1,000이고 주어진 시간 제한이 1초이기 때문에 시간 복잡도 $$O(n^2)$$를 가진 알고리즘까지 적용가능하다고 판단하여 문제를 풀었습니다.

seq 변수에 주어진 수열을 리스트 형태로 저장하고, 동적 계획법(DP) 알고리즘의 메모이제이션을 위한 변수로 dp 리스트를 사용하여 각 seq 원소에 1대1 대응하는 해당 인덱스를 포함하는 부분 수열의 길이의 최대값을 저장하도록 하였습니다.

인덱스 1부터 시작하여(인덱스 0은 무조건 최대 길이는 1이기 때문에) n까지 순회하면서 인덱스 i일때 자신보다 작은 인덱스를 순회하면서 자신보다 작은 원소를 가진(증가하는 부분 수열 조건 성립) 원소를 탐색하고 해당 원소가 현재 i 인덱스에서의 dp 값보다 크거나 같으면 1 더한 값을 자신 인덱스의 dp 값으로 저장하도록 구현하였습니다.

순회가 끝나면 주어진 dp 리스트에서 가장 큰 최대값이 해당 수열에서의 가장 긴 증가하는 부분 수열의 길이이기 때문에 해당 값을 출력하도록 하여 문제 풀이에 성공했습니다.