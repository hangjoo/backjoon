## 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

---

## 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

---

## 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

---

## 풀이

```python
from queue import PriorityQueue

n, k = map(int, input().split())
dist = [-1 for _ in range(100_001)]

pq = PriorityQueue()
dist[n] = 0
pq.put((dist[n], n))

while not pq.empty():
    cur_dist, cur_pos = pq.get()

    if cur_pos == k:
        print(cur_dist)
        break

    if 2 * cur_pos < 100_001 and dist[2 * cur_pos] == -1:
        dist[2 * cur_pos] = cur_dist
        pq.put((dist[2 * cur_pos], 2 * cur_pos))
    if cur_pos - 1 >= 0 and dist[cur_pos - 1] == -1:
        dist[cur_pos - 1] = cur_dist + 1
        pq.put((dist[cur_pos - 1], cur_pos - 1))
    if cur_pos + 1 < 100_001 and dist[cur_pos + 1] == -1:
        dist[cur_pos + 1] = cur_dist + 1
        pq.put((dist[cur_pos + 1], cur_pos + 1))

```

수빈이의 현재 위치와 동생의 현재 위치가 주어졌을 때, 수빈이가 좌우로 1초 걸려 한 칸 이동하거나 순간이동을 통해 (현재 위치 * 2)로 이동이 가능할 때 동생의 위치로 이동하는 가장 빨리 이동하는 경우 걸리는 시간을 구하는 문제입니다.

좌우로 1초 걸려 한 칸씩만 이동이 가능했다면 기본적인 너비우선탐색(BFS)를 사용하여 계산할 수 있지만, 0초 후에 (현재 위치 * 2)로 이동하는 조건으로 인해 기본의 너비우선탐색 방법에서 살짝 변형을 해줘야 합니다.

먼저 기본적으로 너비우선탐색은 처음 방문하는 정점에 대해 해당 걸린 시간이 최단 거리임이 자명합니다. 이에 맞춰 처음 방문할 때 최단 거리가 되도록 만들어줘야하기 때문에 기존의 큐로 구현했던 방식을 우선순위 큐를 사용하여 구현하도록 합니다. 그리고 순간이동을 할 때 현재 위치까지의 최단거리를 기록하고, 한 칸 좌우로 이동할 때는 현재 위치까지의 최단거리에 +1을 하여 기록하도록 합니다. 그리고 해당 정점을 우선순위 큐에 넣게 되면 최단거리가 짧은 정점이 먼저 나오게 되고 해당 정점에서 순간이동을 하면 해당 최단거리 그대로, 좌우로 한 칸 이동한다면 해당 최단거리에 +1이 최단거리가 되기 때문에 기존의 너비우선탐색 방법과 같은 알고리즘으로 구현할 수 있게 됩니다.

모든 정점을 탐색하기에는 모든 정점의 갯수는 100,001개로 너무 많기 때문에 시간 단축을 위해 동생이 위치한 정점에 방문한 순간 해당 정점까지의 최단거리를 출력하고 탐색을 종료하도록 합니다.

기존에 알고 있던 너비우선탐색 알고리즘을 정확하게 이해하고 주어진 문제에 따라 너비우선탐색 알고리즘을 맞게 변형하여 사용할 수 있는지 테스트한 문제였습니다.