## 문제

때는 2020년, 백준이는 월드나라의 한 국민이다. 월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다. (단 도로는 방향이 없으며 웜홀은 방향이 있다.) 웜홀은 시작 위치에서 도착 위치로 가는 하나의 경로인데, 특이하게도 도착을 하게 되면 시작을 하였을 때보다 시간이 뒤로 가게 된다. 웜홀 내에서는 시계가 거꾸로 간다고 생각하여도 좋다.

시간 여행을 매우 좋아하는 백준이는 한 가지 궁금증에 빠졌다. 한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지 궁금해졌다. 여러분은 백준이를 도와 이런 일이 가능한지 불가능한지 구하는 프로그램을 작성하여라.

---

## 입력

첫 번째 줄에는 테스트케이스의 개수 TC(1 ≤ TC ≤ 5)가 주어진다. 그리고 두 번째 줄부터 TC개의 테스트케이스가 차례로 주어지는데 각 테스트케이스의 첫 번째 줄에는 지점의 수 N(1 ≤ N ≤ 500), 도로의 개수 M(1 ≤ M ≤ 2500), 웜홀의 개수 W(1 ≤ W ≤ 200)이 주어진다. 그리고 두 번째 줄부터 M+1번째 줄에 도로의 정보가 주어지는데 각 도로의 정보는 S, E, T 세 정수로 주어진다. S와 E는 연결된 지점의 번호, T는 이 도로를 통해 이동하는데 걸리는 시간을 의미한다. 그리고 M+2번째 줄부터 M+W+1번째 줄까지 웜홀의 정보가 S, E, T 세 정수로 주어지는데 S는 시작 지점, E는 도착 지점, T는 줄어드는 시간을 의미한다. T는 10,000보다 작거나 같은 자연수 또는 0이다.

두 지점을 연결하는 도로가 한 개보다 많을 수도 있다. 지점의 번호는 1부터 N까지 자연수로 중복 없이 매겨져 있다.

---

## 출력

TC개의 줄에 걸쳐서 만약에 시간이 줄어들면서 출발 위치로 돌아오는 것이 가능하면 YES, 불가능하면 NO를 출력한다.

---

## 풀이

```python
INF = 123_456_789

tc = int(input())
for _ in range(tc):
    n, m, w = map(int, input().split())
    connect = []
    for _ in range(m):
        a, b, k = map(int, input().split())
        connect.append((a, b, k))
        connect.append((b, a, k))
    for _ in range(w):
        a, b, k = map(int, input().split())
        connect.append((a, b, -k))

    def bellman_ford(start_node):
        global n
        dist = {node: INF for node in range(1, n + 1)}
        dist[start_node] = 0

        for _ in range(n - 1):
            for src_node, tgt_node, connect_time in connect:
                if dist[src_node] + connect_time < dist[tgt_node]:
                    dist[tgt_node] = dist[src_node] + connect_time

        for src_node, tgt_node, connect_time in connect:
            # occur renewel dist again.
            if dist[src_node] + connect_time < dist[tgt_node]:
                return True
        return False

    if bellman_ford(1):
        print("YES")
    else:
        print("NO")
```

음의 간선을 가진 그래프가 주어졌을 때, 어느 지점에서 출발하여 다시 출발 지점으로 돌아왔을 때 걸린 시간이 음수가 가능한지 여부를 구하는 문제입니다.

가장 먼저 시도한 방법은 깊이우선탐색(DFS)를 사용하여 출발 지점을 다시 방문이 가능할 때 그 때까지 걸린 시간이 음수가 나오는지 확인하는 방법을 사용했으나 당연히 모든 노드에 대해서 깊이 우선 탐색을 처리해야 하는 때문에 시간 초과 오류가 발생했습니다.

두번째는 벨만 포드 알고리즘을 사용하여 한 노드에서 모든 노드에 대한 최단 거리를 계산하고 자신에 대한 최단 거리가 음수일 때를 확인하는 방법으로 구현했습니다. 이 방법 또한 모든 노드에 대해서 벨만 포드 알고리즘을 수행해야 하기 때문에 자신에 대한 최단 거리가 음수일 때 탐색을 멈추는 방법을 사용하여 최대한 시간을 단축했음에도 시간 초과 오류가 발생했습니다.

결국 모든 노드에 대한 탐색이 아닌 한 번의 알고리즘을 통해 자기 자신에 대한 최단 거리가 음수인지 여부를 판단했어야 했습니다. 이는 그래프 내에 사이클이 존재하고 해당 사이클이 음의 사이클인지 여부를 통해 확인할 수 있습니다.

이를 벨만 포드 알고리즘을 통해 확인하는 방법은 다음과 같습니다. 먼저 벨만 포드는 모든 간선을 순회하면서 시작 노드에서 모든 노드까지의 최단 거리를 갱신합니다. 이를 노드의 개수가 N이라고 할 때 (N-1)번 반복함으로써 각 노드까지의 최단 거리를 구할 수 있습니다. 그러나 음의 사이클이 존재할 경우 간선을 다시 순회할 때 최단 거리의 갱신이 발생하지 않음에도 불구하고 갱신이 발생하게 됩니다. 따라서 (N-1)번의 모든 간선 순회를 통해서 최단 거리를 갱신한 후에 다시 한번 모든 간선을 순회하면서 갱신이 발생하는지 여부를 판단함으로써 음의 사이클이 존재하는지 여부를 판단할 수 있고, 음의 사이클이 존재하면 어떤 노드에서 출발해서 다시 자기 자신 노드로 돌아왔을 때 최단 거리가 음수가 존재한다는 것을 의미합니다.

벨만 노드 알고리즘을 수행하는 시작 노드는 주어진 노드 중 어떤 노드를 사용해도 상관 없으나 주의해야할 점이 있습니다. 기존의 벨만 포드 알고리즘을 수행할 때는 $\infty-3 < \infty$ 같은 경우에 갱신되는 것을 막기 위하여 무한대 값이 포함되어있을 경우에는 갱신하지 않도록 구현되어 있습니다. 그러나 이 문제에서는 해당 노드가 아닌 전체 그래프에서 음의 사이클이 존재하는지 여부를 판단해야 하기 때문에 해당 경우에도 갱신이 발생하는지 확인해야 합니다.

![그림1](source/그림1-1614873324199.png)

위 그림과 같이 시작 노드를 1이라고 했을 때 2번 노드에 대한 최단 거리는 현재 무한대인 상태이지만 (2-5-4)로 음의 사이클이 형성된 상태이기 때문에 2번 노드에 대한 최단 거리가 $\infty-7$로 계속해서 발생하게 됩니다.

항상 그래프 관련 문제는 너비 우선 탐색, 깊이 우선 탐색, 다익스트라 정도까지만 이해하고 사용하다가 음의 가중치를 가진 간선을 사용한 그래프 탐색 문제가 나와서 많은 시간이 걸린 문제입니다. 특히나 단순히 벨만 포드를 쓸 줄 아는 것을 물어보는 것이 아니라 동작하는 원리를 정확히 이해하고 문제에 맞춰 어떻게 변형해야 아는지 여부를 확인했던 문제였습니다.