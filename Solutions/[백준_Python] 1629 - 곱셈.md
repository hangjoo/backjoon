## 문제

자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.

---

## 입력

첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.

---

## 출력

첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.

---

## 풀이

```python
a, b, c = list(map(int, input().split()))
dp = dict()


def a_b_mod_c(a, b, c):
    if b == 1:
        return a % c
    else:
        if b not in dp.keys():
            dp[b] = (a_b_mod_c(a, b // 2, c) * a_b_mod_c(a, b - b // 2, c)) % c
        return dp[b]


print(a_b_mod_c(a, b, c))

```

문제 그대로 a를 b번 곱한 수를 c로 나눈 나머지를 구하는 문제입니다. 수의 범위가 2,147,483,647 이하인 자연수인 것만 봐도 직접 구하는게 아니라 어떤 규칙을 찾아서 적용시키라는 것으로 보입니다.

먼저 규칙을 찾기 위해 간단한 예를 보면서 규칙을 찾으려 했습니다.

a, b, c를 각각 3, 5, 5로 설정하면

|  b   | a^b  | a^b mod c |
| :--: | :--: | :-------: |
|  1   |  3   |     3     |
|  2   |  9   |     4     |
|  3   |  27  |     2     |
|  4   |  81  |     1     |
|  5   | 243  |     3     |
|  6   | 729  |     4     |

의 결과를 얻을 수 있습니다. 위의 예들을 보면서 a^b의 연산들은 기본적으로 기하급수적으로 커지기 때문에 사용하지 않을 것이라 판단하였고, a^b mod c를 사용하여 문제를 해결할 수 있을 거라 판단했습니다.

이를 통해 a^b mod c = (a^(n-x) mod c)(a^x mod c) mod c 가 성립하는 규칙을 찾아내어 그 이후로는 동적 계획법을 사용하여 부분 문제로 분할해서 해결할 수 있었습니다.

이 때 메모이제이션을 위해 중간 결과 값을 저장하는 dp 배열을 처음에 리스트를 사용하여 1부터 b까지의 길이를 가진 리스트로 생성하였으나 b의 가능한 범위가 2,147,483,647이므로 메모리 초과가 발생하였고, 중간에 연산하지 않는 수도 많기 때문에 딕셔너리로 바꿔서 필요한 메모리만 차지하도록 수정하였습니다.