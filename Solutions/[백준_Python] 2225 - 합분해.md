## 문제

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

---

## 입력

첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

---

## 출력

첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 해설

```python
n, k = map(int, input().split())
cache = [[1 for _ in range(n + 1)] for _ in range(k)]

for k_i in range(1, k):
    for n_i in range(1, n + 1):
        cache[k_i][n_i] = sum(cache[k_i - 1][: n_i + 1])

print(cache[-1][-1] % 1_000_000_000)
```

0부터 N까지의 정수 중 K개를 골라서 그 합이 N이 되도록 하는 경우의 수를 구하는 문제입니다. 예를 들어 N=5, K=2일 때 경우의 수는 (0+5), (1+4), (2+3), (3+2), (4+1), (5+0)으로 총 6가지입니다.

이런 문제가 익숙하신분들은 벌써 위의 예를 보면서 규칙을 파악하셨을 것이라 생각됩니다. 만약 5까지의 정수 중 2개를 더하는 경우의 수는 5까지의 정수 중 1개를 골라 더하는 경우의 수를 모두 더함으로써 구할 수 있습니다.
$$
solution(n, k)=\sum^n_{i \in n}solution(i, k-1)
$$
예로 5까지의 정수 중 1개를 고르는 경우의 수로 3을 골랐다고 하면 여기에 2를 더함으로써 5까지의 정수 중 2개를 고르는 경우의 수 중 (3, 2)임을 알 수 있습니다.![그림1](source/그림1.png)

이를 코드로 구현하기 위해 먼저 가장 베이스가 되는 K=1의 경우 N이 몇이던 1번 더해서 N이 되려면 N을 한 번 고르는 경우의 수 밖에 없으므로 1로 초기화하게 됩니다. 그리고 0을 고르는 경우 마찬가지로 K가 몇이던 한가지 경우의 수 밖에 없으므로 1로 초기화하게 됩니다. 위 코드에서는 따로 경우의 수 처리를 하지 않고 cache 배열을 선언할 때 모든 원소를 1로 초기화함으로써 생략했습니다.

그리고 나서 n>=1, k>=2인 케이스에 대해서 위 규칙 대로 경우의 수를 저장한뒤 마지막 원소를 1,000,000,000으로 나눈 나머지를 출력하여 문제 풀이에 성공할 수 있었습니다.